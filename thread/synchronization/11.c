//~ Приклад, подібний до попереднього, однак тут:
//~ Один виконує функцію sender -  потік змінює лічильник TCOUNT разів
//~ і звіряє значення лічильника із COUNT_LIMIT_1 та COUNT_LIMIT_2.
//~ В разі рівності із однією із величин, потік надсилає сигнал через умовну зміннну.
//~ Два інші потоки виконують кожен свою функцію: один - waiter_1, другий - waiter_2
//~ Перший потік (waiter_1) очікує на значення лічильника COUNT_LIMIT_1
//~ Другий потік (waiter_2) очікує на значення лічильника COUNT_LIMIT_2

//~ Умовна змінні - це тільки механізм надсилання сигналів про певну подію.
//~ Задача потоку, що очікує на подію, перевірити, чи це точно та подія, яка необхідна йому для продовження роботи
//~ Об'єкти м'ютекса та умовної змінної одні для всіх функцій - бо ми працюємо із одними даними

//~ Дана програма зроблена для візуалізації наступного сценарію:
//~ Припустимо, що потік, який очікує на величину COUNT_LIMIT_2, першим прийшов до умовної змінної, та,
//~ оскільки значення лічильника мале, заснув. 
//~ Другим прийшов лічильник, який очікує на меншу величину COUNT_LIMIT_1, і заснув - він другий в черзі на пробудження
//~ При настанні події (count == COUNT_LIMIT_1), потік sender надсилає одиничний сигнал через pthread_cond_signal.
//~ Пробуджується перший потік в черзі на пробудження (той, що чекає COUNT_LIMIT_2).
//~ Оскільки ми не дали перевірку значення лічильника у функціях waiter_1 та waiter_2,
//~ потік продовжить роботу, незважаючи на те, що по ідеї він би мав чекати значення лічильника =  COUNT_LIMIT_2
//~ Другий потік, що спить, просунеться в черзі - стане першим на пробудження.
//~ Він буде пробудженим, коли sender досягне значення лічильника COUNT_LIMIT_2, та продовжить роботу,
//~ не зважаючи на те, що він чекав COUNT_LIMIT_1

//~ Програма може працювати коректно в певних випадках - це залежить від того, який потік прийде першим до перевірки умовної змінної.
//~ Передбачити який потік першим прийде не можливо - це залежить від планувальника задач.
//~ Для користувача, робота планувальника є непердбачуваною. 

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define TCOUNT		 	20					// Кожний потік інкрементує лічильник TCOUNT разів
#define COUNT_LIMIT_1 		6					// ліміт лічильника
#define COUNT_LIMIT_2 		12					// ліміт лічильника

int count = 0;								// Лічильник
pthread_mutex_t 			mutex;				// м'ютекс для інкрементаторів лічильника 
pthread_cond_t 			condition_variable;		// умовна змінна

void *sender(void *t)
{
	int my_id =  * (int *) t;

	for (int i = 0; i < TCOUNT; i++) {

		// Один потік закриває вхід для іншого, поки працює із глобальними змінними
		pthread_mutex_lock(&mutex);

		//	Запускаємо лічильник

		count++;
		printf("Потік %d змінив лічильник: %d\n", my_id, count);
		// Перевіряємо значення лічильника

		if (count == COUNT_LIMIT_1) {
			// якщо вже досягли ліміту - сигналізуємо іншому потоку
			printf("Потік %d, який змінює лічильник, дійшов до ліміту (%d). Надсилаємо сигнал тому, що очікує... ", my_id, COUNT_LIMIT_1);
			pthread_cond_signal(&condition_variable);
			printf("Сигнал відправлено.\n");
		} else if (count == COUNT_LIMIT_2) {
			// якщо вже досягли ліміту - сигналізуємо іншому потоку
			printf("Потік %d, який змінює лічильник, дійшов до ліміту (%d). Надсилаємо сигнал тому, що очікує... ", my_id, COUNT_LIMIT_2);
			pthread_cond_signal(&condition_variable);
			printf("Сигнал відправлено.\n");
		}
		// Відкриваємо вхід іншому потоку.
		pthread_mutex_unlock(&mutex);
		// для тестів сповільнимо роботу
		sleep(1);
	}
	pthread_exit(NULL);
}
//Перший обробник, який по ідеї би мав чекати на значення COUNT_LIMIT_1
void *waiter_1(void *t)
{
	//~ В даній програмі, потоки виконують мало операцій  перед перевіркою умовної змінної - вистачає часу
	//~ виділеного планувальником на один цикл роботи, щоб дійти до умовної змінної без переривань
	//~ Тут ми дамо паузу для імітації бурхливої рооботи потоку
	sleep(1);
	int my_id =  * (int *) t;

	printf("Потік %d очікує значення лічильника: %d\n", my_id, COUNT_LIMIT_1);
	// тут спимо до отримання сигналу
	pthread_mutex_lock(&mutex);
	pthread_cond_wait(&condition_variable, &mutex);
	pthread_mutex_unlock(&mutex);
	printf("Потік %d (чекає на %d) дочекався значення лічильника %d\n", my_id, COUNT_LIMIT_1, count);

	pthread_exit(NULL);
}

//Другий обробник, який по ідеї би мав чекати на значення COUNT_LIMIT_2
void *waiter_2(void *t)
{
	//~ Тут ми дамо паузу для імітації бурхливої рооботи потоку
	sleep(1);
	int my_id =  * (int *) t;

	printf("Потік %d очікує значення лічильника: %d\n", my_id, COUNT_LIMIT_2);
	// тут спимо до отримання сигналу
	pthread_mutex_lock(&mutex);
	pthread_cond_wait(&condition_variable, &mutex);
	pthread_mutex_unlock(&mutex);
	printf("Потік %d (чекає на %d) дочекався значення лічильника %d\n", my_id, COUNT_LIMIT_2, count);

	pthread_exit(NULL);
}

int main(int argc, char *argv[])
{
	//~ Отримуємо ID процесу та друкуємо його в термінал
	pid_t init_pid = getpid();
	printf("ID процесу: %d\n", init_pid);
	pthread_t threads[3];
	//~ Оголосимо деякі змінні типу int, ядреси яких передамо в функцію потку як аргумент
	int num[3] = {1, 2, 3};

	// Ініціалізуємо м'ютекси та умовну змінну
	pthread_mutex_init(&mutex, NULL); 
	pthread_cond_init (&condition_variable, NULL);
	
	//~ Створюємо три потоки та передамо їм адреси змінної
	//~ Два потоки виконують функцію sender, третій - waiter
	pthread_create(&threads[0], NULL, sender, (void *) &num[0]);
	 
	
	pthread_create(&threads[1], NULL, waiter_1, (void *) &num[1]);
	pthread_create(&threads[2], NULL, waiter_2, (void *) &num[2]);
	
	//~ Чекаємо на завершення потоків.
	//~ Тут NULL - ми не чекаємо, що функція потоку нам щось поверне
	pthread_join(threads[0], NULL);
	pthread_join(threads[1], NULL);
	pthread_join(threads[2], NULL);

	// знищимо декскриптори об'єктів - не обов'язково, оскільки і так процес завершується
	pthread_mutex_destroy(&mutex); 
	pthread_cond_destroy(&condition_variable);
	return 0; 
}

