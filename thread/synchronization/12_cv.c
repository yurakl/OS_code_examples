//~ Приклад, подібний до попереднього, однак тут:
//~ Один виконує функцію sender -  потік змінює лічильник TCOUNT разів
//~ і звіряє значення лічильника із COUNT_LIMIT_1 та COUNT_LIMIT_2.
//~ В разі рівності із однією із величин, потік надсилає сигнал через умовну зміннну.
//~ Два інші потоки виконують кожен свою функцію: один - waiter_1, другий - waiter_2
//~ Перший потік (waiter_1) очікує на значення лічильника COUNT_LIMIT_1
//~ Другий потік (waiter_2) очікує на значення лічильника COUNT_LIMIT_2

//~ Умовна змінні - це тільки механізм надсилання сигналів про певну подію.
//~ Задача потоку, що очікує на подію, перевірити, чи це точно та подія, яка необхідна йому для продовження роботи
//~ Об'єкти м'ютекса та умовної змінної одні для всіх функцій - бо ми працюємо із одними даними

//~ Дана програма зроблена для візуалізації наступного сценарію:
//~ Тут ми у функціях потоків, що чекають на певне значення лічильника, додали перевірку
//~ значення лічильника при надходженні сигналу:
//~ while( count != COUNT_LIMIT_1) {
		//~ ...
		//~ pthread_mutex_lock(&mutex);
		//~ pthread_cond_wait(&condition_variable, &mutex);
		//~ pthread_mutex_unlock(&mutex);
		//~ ...
	//~ }
//~ Якщо потік дійшов до даної точки, він перевіряє значення лічильника.
//~ Оскільки лічильник має менше значення, ніж потрібне, потік йде далі до перевірки умовної змінної.
//~ Сигнал через умовну змінну не надходив. Потік засинає.
//~ Коли потік із функцією sender, досягає значення COUNT_LIMIT_1, він надсилає сигнал через умовну змінну.
//~ Потік прокидається, перевіряє значення лічильника використовуючи while.
//~ Якщо це необхідне значення - потік продовжує роботу після блоку while {...}.
//~ Якщо значення лічильника не те, на яке очікував даний потік - він входить у блок while,
//~ сигнал, що його пробудив вже оброблений, нових сигналів не було, тому потік знову засинає.

//~ В даній програмі може бути (в певних випадках) наступна поведінка:

//~ Потік (waiter_2), що очікує на більше значення лічильника (COUNT_LIMIT_2), прийшов першим до умовної змінної
//~ та першим заснув - перший на пробудження. 
//~ Потік (waiter_1), що очікує на менше значення лічильника (COUNT_LIMIT_1), прийшов другим до умовної змінної
//~ та заснув - другий на пробудження.

//~ Потік (sender) досягає значення COUNT_LIMIT_1 та надсилає одиничний сигнал через pthread_cond_signal.
//~ Потік (waiter_2), що очікує на більше значення лічильника (COUNT_LIMIT_2), прокидається, перевіряє умову -
//~ умова не виконується. Потік (waiter_1) стає першим в черзі на пробудження, потік (waiter_2) стає другим в чергу на пробудження.

//~ Потік (sender) досягає значення COUNT_LIMIT_2 та надсилає одиничний сигнал через pthread_cond_signal.
//~ Потік (waiter_1), що очікує на менше значення лічильника (COUNT_LIMIT_1), прокидається, перевіряє умову -
//~ умова не виконується - потік засинає.

//~ Наші два потоки сплять і вже не будуть пробуджені - програма "зависає"

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define TCOUNT		 	20					// Кожний потік інкрементує лічильник TCOUNT разів
#define COUNT_LIMIT_1 		6					// ліміт лічильника
#define COUNT_LIMIT_2 		12					// ліміт лічильника

int count = 0;								// Лічильник
pthread_mutex_t 			mutex;				// м'ютекс 
pthread_cond_t 			condition_variable;		// умовна змінна

void *sender(void *t)
{
	int my_id =  * (int *) t;

	for (int i = 0; i < TCOUNT; i++) {

		// Один потік закриває вхід для іншого, поки працює із глобальними змінними
		pthread_mutex_lock(&mutex);

		//	Запускаємо лічильник

		count++;
		printf("Потік %d змінив лічильник: %d\n", my_id, count);
		// Перевіряємо значення лічильника

		if (count == COUNT_LIMIT_1) {
			// якщо вже досягли ліміту - сигналізуємо іншому потоку
			printf("Потік %d, який змінює лічильник, дійшов до ліміту (%d). Надсилаємо сигнал тому, що очікує... ", my_id, COUNT_LIMIT_1);
			pthread_cond_signal(&condition_variable);
			printf("Сигнал відправлено.\n");
		} else if (count == COUNT_LIMIT_2) {
			// якщо вже досягли ліміту - сигналізуємо іншому потоку
			printf("Потік %d, який змінює лічильник, дійшов до ліміту (%d). Надсилаємо сигнал тому, що очікує... ", my_id, COUNT_LIMIT_2);
			pthread_cond_signal(&condition_variable);
			printf("Сигнал відправлено.\n");
		}
		// Відкриваємо вхід іншому потоку.
		pthread_mutex_unlock(&mutex);
		// для тестів сповільнимо роботу
		sleep(1);
	}
	pthread_exit(NULL);
}
//Перший обробник, який по ідеї би мав чекати на значення COUNT_LIMIT_1
void *waiter_1(void *t)
{
	//~ В даній програмі, потоки виконують мало операцій  перед перевіркою умовної змінної - вистачає часу
	//~ виділеного планувальником на один цикл роботи, щоб дійти до умовної змінної без переривань
	//~ Тут ми дамо паузу для імітації бурхливої рооботи потоку
	sleep(1);
	int my_id =  * (int *) t;

	
	//~ тут спимо до отримання сигналу
	while( count != COUNT_LIMIT_1) {
		printf("Потік %d очікує значення лічильника: %d\n", my_id, COUNT_LIMIT_1);
		pthread_mutex_lock(&mutex);
		pthread_cond_wait(&condition_variable, &mutex);
		pthread_mutex_unlock(&mutex);
		printf("Потік %d (чекає на %d) отриимав сигнал. Перевіряє умову для продовження роботи...\n", my_id, COUNT_LIMIT_1);
	}
	printf("Потік %d (чекає на %d) дочекався значення лічильника %d\n", my_id, COUNT_LIMIT_1, count);

	pthread_exit(NULL);
}

//Другий обробник, який по ідеї би мав чекати на значення COUNT_LIMIT_2
void *waiter_2(void *t)
{
	//~ Тут ми дамо паузу для імітації бурхливої рооботи потоку
	sleep(1);
	int my_id =  * (int *) t;
	
	//~ тут спимо до отримання сигналу
	while( count != COUNT_LIMIT_2) {
		printf("Потік %d очікує значення лічильника: %d\n", my_id, COUNT_LIMIT_2);
		pthread_mutex_lock(&mutex);
		pthread_cond_wait(&condition_variable, &mutex);
		pthread_mutex_unlock(&mutex);
		printf("Потік %d (чекає на %d) отриимав сигнал. Перевіряє умову для продовження роботи...\n", my_id, COUNT_LIMIT_2);
	}
	printf("Потік %d (чекає на %d) дочекався значення лічильника %d\n", my_id, COUNT_LIMIT_2, count);

	pthread_exit(NULL);
}

int main(int argc, char *argv[])
{
	//~ Отримуємо ID процесу та друкуємо його в термінал
	pid_t init_pid = getpid();
	printf("ID процесу: %d\n", init_pid);
	pthread_t threads[3];
	//~ Оголосимо деякі змінні типу int, ядреси яких передамо в функцію потку як аргумент
	int num[3] = {1, 2, 3};

	// Ініціалізуємо м'ютекси та умовну змінну
	pthread_mutex_init(&mutex, NULL); 
	pthread_cond_init (&condition_variable, NULL);
	
	//~ Створюємо три потоки та передамо їм адреси змінної
	//~ Один потік виконує функцію sender
	pthread_create(&threads[0], NULL, sender, (void *) &num[0]);
	 
	//~ Два інші потоки виконують функції waiter_1 та waiter_2, відповідно.
	pthread_create(&threads[1], NULL, waiter_1, (void *) &num[1]);
	pthread_create(&threads[2], NULL, waiter_2, (void *) &num[2]);
	
	//~ Чекаємо на завершення потоків.
	//~ Тут NULL - ми не чекаємо, що функція потоку нам щось поверне
	pthread_join(threads[0], NULL);
	pthread_join(threads[1], NULL);
	pthread_join(threads[2], NULL);

	// знищимо декскриптори об'єктів - не обов'язково, оскільки і так процес завершується
	pthread_mutex_destroy(&mutex); 
	pthread_cond_destroy(&condition_variable);
	return 0; 
}

