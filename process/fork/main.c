// В даному прикладі показана конструкція коду для роботи із системною функцією fork()
// fork() клонує процес - копіює всі ресурси в адресний простір нового процесу, копіює вказівники на відкриті файли, копіює обробники сигналів і тд.
// fork() повертає в бітьківстький процес значення PID новоствореного (дочірнього) процесу.
// fork() повертає в дочірній процес 0.
// Оскільки код в обидвох процесах однаковий, нам потрібно розділити роботу процесів через перевірку поверненого значення функцією fork()
// 	pid_t c_pid = fork()
// Якщо (c_pid == 0) ми в дочірньому процесі
// Якщо (c_pid > 0) ми в батьківському процесі
// Якщо (c_pid < 0) помилка створення процесу

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main(){
	// Візьмемо та видрукуємо PID процесу до виклику fork()
	pid_t init_pid = getpid();
	printf("PID до виклику fork(): %d\n", init_pid);
	// Клонуємо наш процес
	pid_t c_pid = fork();
	if( c_pid == 0 ){
		// Функція fork() повернула 0 - ми в дочірньому процесі
		printf("Дочірній процес. Функція fork() повернула значення: %d\n", c_pid);
		// Візьмемо та видрукуємо PID дочірнього процесу
		pid_t this_pid = getpid();
		printf("Дочірній процес. Присвоєний PID: %d\n", this_pid);
		// Павза
		getc(stdin);
	} else if (c_pid > 0){
		// Функція fork() повернула позитивне значення (PID дочірнього процесу) - ми в батьківському процесі
		printf("Батькіський процес. Функція fork() повернула значення (має бути PID дочірнього): %d\n", c_pid);
		// Візьмемо та видрукуємо PID батьківського процесу
		pid_t this_pid = getpid();
		printf("Батькіський процес. Присвоєний PID (має бути таким же,  як і до виклику fork): %d\n", this_pid);
		// Павза
		getc(stdin);
	} else {
		// Функція fork() повернула негативне значення - помилка
		perror("Помилка");
		// Вихід з програми
		_exit(2);

	}
	return 0;
}
