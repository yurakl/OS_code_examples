// Приклад програми, що створює дочірній процес шляхом дублювання батьківського - fork()
// До моменту розгалуження оголошуються два файлові дескриптори та створюється конвеєр
// Батьківський процес записує рядок в один кінець конвеєра, дочірній зчитує текст з іншого

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>

// Розмір повідомлення
#define BUFS 256

int main(int argc, char * argv[]){

// Оголошуємо два файлові декриптори
	int pfd[2]; //	pfd[0] для читання
			//	pfd[1] для запису

	pid_t cpid;
	int status;

	// Створення конвеєру
	if ( pipe(pfd) < 0){
		perror("Створення конвеєру");
		return 1;
	}
	// Стоврення процесу
	cpid = fork();

	if( cpid == 0 ){
		// Ми в дочірньому процесі
		// Закриваємо сторону конвеєра для запису. Тут ми будемо тільки читати з нього
		close(pfd[1]);
		// Буфер для зчитування повідомлення
		char buff[BUFS];
		// Читаємо з конвеєра
		read(pfd[0], buff, BUFS);
		// Виводимо повідомлення
		puts(buff);

		// Закриваємо конвеєр
		close(pfd[0]);

		_exit(0);
	} else if ( cpid > 0) {
		// Батьківський процес
		// Повідомлення, яке ми надішлемо
		char hello[] = "Hello World!";

		// Закриваємо кінець конвеєра для читання. Тут ми тільки записуємо в конвеєр
		close(pfd[0]);

		// Записуємо наше повідомлення в конвеєер
		write(pfd[1], hello, strlen(hello));

		// Закриваємо конвеєер
		close(pfd[1]);

		// Чекаємо на завершення дочірнього процесу
		wait(&status);

	} else {
		// Помилка створення процесу
		perror("fork");
		return 1;
	}

	return 0;
}
