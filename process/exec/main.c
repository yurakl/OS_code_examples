// Приклад використання виклику execv
// Скомпілюйте два файли func.c та main.c в окремі програми func та main.
// В main встановлена зупинка програми getc(stdin) до виклику exec.
// Коли програма зупиниться, спробуйте переглянути вміст адресного простору процесу.
// Для цього в окремому терміналі виконайте команду pmap PID, де PID це ідентифікатор процесу.
// PID ми отримуємо та виводимо в консоль тут
	// pid_t pid = getpid();
// 	// printf("We are in: %d\n", pid);
// Перші області пам'яті будуть заповнені сегментами програми main
// Далі нажміть ENTER для продовження роботи програми.
// Після виконання системного виклику execv, в адресний простір процесу буде завантажена програма func
// У програмі func є теж точка зупинки...  Виконайте знову pmap PID. PID не зміниться після виклику execv
// Тепер початкова область пам'яті процесу заповнена сегментами програми func

#include <stdio.h>
#include <unistd.h>

int main()
{
	// Отримуємо PID процесу та друкуємо в термінал
	pid_t pid = getpid();
	printf("We are in: %d\n", pid);
	// Готуємо аргументи для func - їх немає, тому передаємо NULL
	char * argv[] = {NULL};
	// Зупинка для перевірки заповнення адресного простору через pmap PID
	getc(stdin);
	// Тепер виконуємо execv - завантажуємо програму func
	execv("func", argv);
	//~ Наступне буде виконано тільки тоді, якщо execv не вдасться завантажити програму (в основному, якщо програму не знаходить - не правильне ім'я або шлях). 
	//~ Якщо execv виконалась успішно, то сюди ми вже ніколи не повернемось.
	// Можете змінити перший аргумент в execv("func") на неправильну назву("func1"), перекомпілювати main, та запустити.
	printf("Exec failed\n");

	return 0;
}
